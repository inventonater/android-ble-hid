# Best-Practice Project Structure for a Unity Java Plugin with Shared Core

Developing a Unity Android plug-in in Java alongside a regular Android app can be organized with a modular project structure. The goal is to **separate the core logic from the Unity-specific and Android-specific code**, making it easy to reuse functionality and minimize integration headaches. Below is a recommended layout and approach that emphasizes simplicity (avoiding complex Gradle tricks) and smooth Unity integration (avoiding messy manifest merges).

## Project Structure Overview

It's best to set up a **multi-module project** with three modules:
1. a **Core** library module containing the Java logic (shared by both Unity and the Android app),
2. a **Unity Plugin** module which is an Android Library acting as a wrapper to expose the core functionality to Unity, and 
3. an **Android App** module used for testing or demonstrating the core functionality in a standalone app.

This follows the Android library practice of reusing components across multiple applications ([Unity - Manual:  AAR plug-ins and Android Libraries](https://docs.unity3d.com/2020.1/Documentation/Manual/AndroidAARPlugins.html#:~:text=Use%20Android%20Libraries%20to%20reuse,for%20an%20Android%20app%20module)). For example, your project directory might look like this:

```plaintext
MyPluginProject/
├── core/                      # Core Java library (reusable logic, no Unity-specific code)
│   ├── src/main/java/...      # Core Java source code (pure logic, can include Android APIs if needed)
│   └── build.gradle           # Gradle config for core (use Java library or Android library plugin)
├── unity-plugin/              # Unity plugin Android Library (wrapper exposing core to Unity)
│   ├── src/main/java/...      # Unity-specific wrapper code (calls into core)
│   ├── src/main/AndroidManifest.xml  # Manifest for plugin (permissions or components needed in Unity)
│   └── build.gradle           # Gradle config for Unity plugin (uses com.android.library, depends on core)
├── app/                       # Regular Android app (for testing core functionality)
│   ├── src/main/java/...      # Sample app source (uses core library to exercise features)
│   ├── src/main/AndroidManifest.xml  # Manifest for the test app
│   └── build.gradle           # Gradle config for Android application
├── settings.gradle            # Includes ':core', ':unity-plugin', ':app' modules
└── build.gradle               # Top-level Gradle settings (plugin versions, etc.)
```

- **Core module:** Contains all the core logic in Java. This module should have **no Unity-specific classes** and ideally no Android-specific UI or Unity dependencies. It can be a plain Java library (`apply plugin: 'java-library'`) if it doesn’t use Android SDK APIs, producing a `.jar`. If the core functionality does need Android classes (e.g. `Context`, sensors, etc.), use the Android Library plugin (`com.android.library`) so you can compile against the Android SDK – this will produce an AAR (Android Archive) or you can still extract a JAR of its classes. The core module should **not** depend on Unity; it should be usable in any Java context (including a normal Android app). This separation makes the core easily testable and reusable.

- **Unity plugin module:** An Android Library module that serves as the **bridge between Unity and the core library**. This is where you put any code that Unity’s C# will call via the Android JNI/Java interface. For example, you might have a class with static methods that Unity calls, which in turn invoke the core library’s methods. This module will produce an **AAR plug-in** containing the Java code and an AndroidManifest for Unity. The plugin module should **depend on the core module** (e.g., in Gradle `implementation project(':core')`) so it can use the core logic. Keep the Unity plugin code minimal – just what's needed to interface with Unity or handle Android-specific details (for instance, retrieving a `Context` from Unity’s activity and passing it to the core, if needed). *Importantly, avoid direct references to Unity classes inside this module if you want to test it outside Unity.* Instead, have Unity pass in any needed Android `Activity` or parameters to your plugin API. This way the plugin module can be used in the test app as well. (In Unity, you can obtain the current Activity via `UnityPlayer.currentActivity` in C# and pass it through to the plugin call, rather than the Java plugin pulling in Unity classes.) 

- **Android app module:** A standard Android **application module** for testing and development. This app can depend on the core module (and possibly the plugin module if you want to test the exact Unity wrapper calls, though often you can call core logic directly). Its `AndroidManifest.xml` will declare any components needed to run the app. Use this app to verify that the core logic works as expected in an Android environment and to ensure that any required Android permissions or features are identified early. It’s essentially a simple harness to run the core functionality without Unity. This module is not shipped to Unity; it's just for your development convenience.

With this setup, you have a clear separation of concerns: the **core** contains the core functionality, the **Unity plugin** wraps it for Unity, and the **app** provides a sandbox to run the core outside of Unity. This mirrors the idea of an Android library used in multiple apps ([Unity - Manual:  AAR plug-ins and Android Libraries](https://docs.unity3d.com/2020.1/Documentation/Manual/AndroidAARPlugins.html#:~:text=Use%20Android%20Libraries%20to%20reuse,for%20an%20Android%20app%20module)) (Unity being one “app” and your test app being another).

## AndroidManifest Considerations (Minimizing Merge Issues)

One advantage of using an Android Library/AAR for the Unity plugin is that you can include an AndroidManifest.xml in the library. Unity’s Gradle build will automatically **merge this manifest** with the final application manifest at build time ([Managing the Android Manifest in Unity - DEV Community](https://dev.to/attiliohimeki/managing-the-android-manifest-in-unity-221o#:~:text=Finally%2C%20most%20Plug,to%20make%20them%20work%20together)) ([Managing the Android Manifest in Unity - DEV Community](https://dev.to/attiliohimeki/managing-the-android-manifest-in-unity-221o#:~:text=At%20build%20time%20Unity%20will,the%20Plugins%20and%20SDKs%20manifests)). To avoid any “complex merging” problems, follow these best practices for your manifests:

- **Declare only what’s necessary in the plugin manifest:** Include required permissions (`<uses-permission>`), features (`<uses-feature>`), and any components your plugin needs (services, receivers, etc.) in `unity-plugin/src/main/AndroidManifest.xml`. This ensures those requirements are added to the final Unity app manifest automatically ([Managing the Android Manifest in Unity - DEV Community](https://dev.to/attiliohimeki/managing-the-android-manifest-in-unity-221o#:~:text=Finally%2C%20most%20Plug,to%20make%20them%20work%20together)). For example, if your plugin needs camera access or uses sensors, declare those permissions here. Unity will merge these entries into the final manifest without you having to manually edit it. Most well-designed Unity plugins provide their own manifest entries to satisfy their requirements ([Managing the Android Manifest in Unity - DEV Community](https://dev.to/attiliohimeki/managing-the-android-manifest-in-unity-221o#:~:text=Finally%2C%20most%20Plug,to%20make%20them%20work%20together)).

- **Avoid conflicting manifest entries:** *Do not declare an `<application>` element or attributes like `android:allowBackup` in the library manifest* unless absolutely needed. The Unity player’s main manifest will define the application and common attributes. If your library manifest declares an `<application>` tag with certain attributes, it could conflict or override Unity’s default. Usually, for an Android library project, you only declare your plugin’s components inside a generic `<application>` tag (no `android:name` for Application class unless you intend to replace it) so that they merge into Unity’s application. Keep activity definitions out of the plugin unless your plugin *requires* a custom Activity – in most cases, Unity uses its own `UnityPlayerActivity`. Ideally, your plugin should not replace the main activity; if you must use a custom activity or modify Unity’s, it complicates merging (and should be documented clearly). For simplicity, **rely on Unity’s default activity** and use the UnityPlayer activity reference if you need a context.

- **Omit the `<uses-sdk>` element in library manifests:** The Unity build process will set the SDK versions according to the Unity **Player Settings**. If your plugin’s manifest or Gradle config specifies `minSdkVersion` or `targetSdkVersion`, it could introduce a manifest merge conflict (duplicate `<uses-sdk>` definitions). To avoid this, you can simply not include a `<uses-sdk>` line in the plugin’s AndroidManifest.xml (it’s usually not needed in library manifests). If the build tools inject it, you can add a Gradle manifest merge rule to remove it or ensure it matches Unity’s settings. Keeping SDK versions only in Unity’s main settings minimizes merge issues. Unity’s own manifest (Library Manifest) typically has priority and will override library values in case of conflict ([Managing the Android Manifest in Unity - DEV Community](https://dev.to/attiliohimeki/managing-the-android-manifest-in-unity-221o#:~:text=In%20case%20of%20conflicts%2C%20the,from%20manifests%20with%20lower%20priority)).

- **Unique package names:** Ensure the manifest entries (like receivers, services) use unique package names/namespaces (usually your plugin’s package) so they don’t collide with other plugins. This is typically done by having your Android library’s manifest `<manifest package="com.yourcompany.yourplugin">` to namespace its components. Unity will merge them under the hood, and because they’re namespaced, conflicts are unlikely.

By following these practices, **manifest merging becomes a non-issue** – Unity’s Gradle build will include your plugin’s manifest entries automatically, with no manual merges required. In summary, put the necessary declarations in the plugin’s AndroidManifest, but keep it minimal and compatible with Unity’s defaults. Unity will handle merging for you at build time ([Managing the Android Manifest in Unity - DEV Community](https://dev.to/attiliohimeki/managing-the-android-manifest-in-unity-221o#:~:text=Finally%2C%20most%20Plug,to%20make%20them%20work%20together)) ([Managing the Android Manifest in Unity - DEV Community](https://dev.to/attiliohimeki/managing-the-android-manifest-in-unity-221o#:~:text=At%20build%20time%20Unity%20will,the%20Plugins%20and%20SDKs%20manifests)).

## Packaging the Plugin (AAR vs JAR) and Unity Integration

For Unity integration, the simplest and most robust approach is to package your Unity plugin module as an **Android Archive (AAR)**. An AAR is essentially a compiled Android Library that bundles **everything**: the compiled `.class` files (as a JAR), resources (if any), and the manifest, all in one file ([Unity - Manual: Introducing Android Library and Android Archive plug-ins](https://docs.unity3d.com/6000.0/Documentation/Manual/android-library-project-and-aar-plugins-introducing.html#:~:text=An%20Android%20Archive%20%28AAR%29%20plug,of%20an%20AAR%2C%20refer%20to)). Unity supports AAR plug-ins natively and even **recommends using AAR format** for distributing Android plugins ([Unity - Manual: Introducing Android Library and Android Archive plug-ins](https://docs.unity3d.com/6000.0/Documentation/Manual/android-library-project-and-aar-plugins-introducing.html#:~:text=Android%20Archives%20are%20a%20compiled,the%20future%2C%20or%20want%20to)). 

**Why AAR?** Using an AAR for the plugin means you can include the AndroidManifest and any Android resources in that single package. In contrast, a plain JAR can only hold the compiled Java code – no manifest or resources. If you used a JAR for the plugin, you’d have to manually provide a manifest (e.g., as an `Assets/Plugins/Android/AndroidManifest.xml` in Unity) to declare permissions or other requirements, which is more error-prone. Unity Technologies notes that Android Archives are the *recommended way* to format plugins for distribution ([Unity - Manual: Introducing Android Library and Android Archive plug-ins](https://docs.unity3d.com/6000.0/Documentation/Manual/android-library-project-and-aar-plugins-introducing.html#:~:text=Android%20Archives%20are%20a%20compiled,the%20future%2C%20or%20want%20to)), precisely because they encapsulate all needed components.

**Building the AAR:** In Android Studio or Gradle, configure the **`unity-plugin` module** as an Android Library (`com.android.library`). Make sure the module’s Gradle dependencies include the core module (e.g., `implementation project(':core')`). When you build this module (e.g., using **Make Project** or the `assembleRelease` Gradle task), it will output an AAR file. You’ll typically find it under `unity-plugin/build/outputs/aar/` (for example, `unity-plugin-release.aar`) ([Create and import a custom android library in Unity3D | by Vishnu Sivan | Medium](https://codemaker2016.medium.com/create-and-import-a-custom-android-library-in-unity3d-ed7f848c6c54#:~:text=After%20compilation%2C%20you%20will%20find,name%3E%5Cbuild%5Coutputs%5Caar%60%20folder)). The core module (if it’s a plain Java lib) will produce a JAR (e.g., under `core/build/libs/`). 

Now you have two choices for packaging the core with the plugin:
- **Option A:** Package core code inside the AAR. This can be done by ensuring the core module’s classes are compiled into the plugin AAR. By default, Gradle will compile against the core module but **won’t automatically bundle** those classes into the AAR unless configured. To include them, the simplest way is to treat the core as an Android library as well and add it to Unity (Option B below). Alternatively, you could embed the core JAR into the plugin AAR manually (this requires a Gradle tweak or adding the JAR to the plugin module’s libs directory). Given the priority on simplicity, this is usually not necessary – it adds complexity to the build.
- **Option B:** Distribute the core library separately to Unity. Since the core has no manifest or resources, you can just include its JAR alongside the AAR. Unity will merge any Java bytecode from all plugins into the final APK, so having an additional JAR is fine. This approach is straightforward: **copy both the plugin AAR and the core JAR into Unity**. Unity will pick up the classes from the JAR and the AAR’s classes/manifest automatically. 

> **Recommendation:** For simplicity, include the core’s artifact separately in Unity rather than using a complex Gradle solution to bundle it. This means you'll provide two files to Unity: your `MyPlugin.aar` (Unity plugin wrapper) and `core.jar` (core logic). This avoids any “fat AAR” Gradle configuration. Just be sure not to accidentally omit the core JAR, or the classes the plugin expects won’t be found at runtime.

**Integrating into Unity:** Once you have your compiled plugin (and core library), integration is very easy:
- In your Unity project, create the folder `Assets/Plugins/Android/` (Unity typically uses this path for Android native plugins). Copy the `*.aar` file (and any supplemental .jar files) into this folder ([Create and import a custom android library in Unity3D | by Vishnu Sivan | Medium](https://codemaker2016.medium.com/create-and-import-a-custom-android-library-in-unity3d-ed7f848c6c54#:~:text=Open%20your%20Unity3D%20project%20and,debug.aar%60%29%20inside%20the%20folder)).
- Back in Unity, select the imported AAR file in the Project browser. In the Inspector, **check the platform** for which it’s enabled – tick “Android” (Unity usually auto-detects from the extension, but it’s good to verify) ([Unity - Manual:  AAR plug-ins and Android Libraries](https://docs.unity3d.com/2020.1/Documentation/Manual/AndroidAARPlugins.html#:~:text=To%20add%20an%20AAR%20plug,file%20as%20compatible%20with%20Unity)). Do the same for any JAR (Unity will often mark .jar plugins for Android by default when placed under Plugins/Android).
- That’s it – Unity will include these during the Android build. You do **not** need to manually add references in Unity; any .jar in `Plugins/Android` and any .aar marked for Android are automatically recognized in the Unity build pipeline.

Unity’s build process will treat your AAR as an Android Library dependency. It will unpack the AAR, merge its manifest, include its resource files (if any), and compile its classes into the final APK. In fact, Unity uses Gradle under the hood to merge all plugin libraries into the final project ([Unity - Manual: Introducing Android Library and Android Archive plug-ins](https://docs.unity3d.com/6000.0/Documentation/Manual/android-library-project-and-aar-plugins-introducing.html#:~:text=several%20build%20processes,when%20they%20have%20multiple%20subprojects)). As long as your plugin and core were built properly, Unity will find the classes and not complain about anything missing. (If you see a **“Duplicate class”** error during Unity build, it could mean you accidentally included the core classes twice – e.g., in both the AAR and a JAR. In that case, remove one of them. Likewise, an **“Unable to merge manifest”** error would indicate a conflict in manifest definitions, which the guidelines above aim to avoid.)

**Calling the plugin from Unity:** From the Unity side (C# code), you can call into your Java plugin using Unity’s AndroidJavaObject/AndroidJavaClass API. For example, if your plugin’s Java class `UnityPluginClass` has a static method `init(Context ctx)`, you would do something like: 

```csharp
using UnityEngine;
...
#if UNITY_ANDROID && !UNITY_EDITOR
AndroidJavaClass pluginClass = new AndroidJavaClass("com.yourcompany.yourplugin.UnityPluginClass");
AndroidJavaObject unityActivity = new AndroidJavaClass("com.unity3d.player.UnityPlayer")
                                     .GetStatic<AndroidJavaObject>("currentActivity");
pluginClass.CallStatic("init", unityActivity);
#endif
``` 

In this way, the Unity C# passes the current `Activity` to your plugin (which can forward it to core logic). This ensures your plugin doesn’t need to reference Unity’s classes internally, and keeps the core code usable in the separate app. (The C# call is just an example of usage; you’ll structure it based on what your plugin does.)

## Minimal Configuration and Maintenance

This structure is designed to minimize configuration complexity:
- **Simple Gradle setup:** Each module can use standard Gradle build scripts (no special build flavors or complicated Gradle tasks needed). The core and plugin modules are decoupled, which means you can build and test them in isolation. For instance, you can write unit tests for the core module easily. The app module can directly depend on the core (and even the plugin library, if needed) via Gradle for quick testing.
- **Straightforward Unity packaging:** Using an AAR for the Unity plugin means you don’t have to manually sync AndroidManifest files. The manifest inside the AAR will be merged by Unity’s Gradle build automatically ([Managing the Android Manifest in Unity - DEV Community](https://dev.to/attiliohimeki/managing-the-android-manifest-in-unity-221o#:~:text=At%20build%20time%20Unity%20will,the%20Plugins%20and%20SDKs%20manifests)). This **avoids manual manifest merging** or editing in most cases. The Unity plugin AAR also bundles any resources or assets if you had them. (If your plugin needed to include some Android resource files or libraries, they too would be handled inside the AAR).
- **Compatibility with Unity 6+:** Unity 2019 and above introduced the Gradle “Unity as a Library” feature, but for a standard plugin, the integration remains the same. Unity 6 (the latest as of 2025) uses a recent Gradle version and supports library dependency merging out of the box. By following the above structure, you ensure your plugin is packaged in the **recommended format (AAR)** ([Unity - Manual: Introducing Android Library and Android Archive plug-ins](https://docs.unity3d.com/6000.0/Documentation/Manual/android-library-project-and-aar-plugins-introducing.html#:~:text=Android%20Archives%20are%20a%20compiled,the%20future%2C%20or%20want%20to)), which Unity 6 will recognize and handle gracefully. You also avoid legacy techniques (like dropping loose files without guidance). Just ensure your Android SDK/NDK tools for Unity are up to date so that Gradle 8+ can build with your plugin; Unity 6 will handle the Gradle project generation and merging.
- **Minimal manifest conflict risk:** Because we keep the plugin manifest simple (no `<uses-sdk>` and no overriding Unity’s Application), the chance of merge conflicts is extremely low. Unity will simply add your declarations to its own. In most cases you won't need any custom Gradle configuration or Unity build scripts tweaks. If you ever do need to adjust the manifest (say two plugins conflict on something), Unity allows using `tools:replace` or custom manifest files, but those are advanced scenarios – with this setup, you likely won’t run into them.

**Summary of Recommendations:**
- Use a **core library module** for shared logic and a **separate Android library module** as the Unity plugin. This keeps code organized and reusable, aligning with Android’s modular design ([Unity - Manual:  AAR plug-ins and Android Libraries](https://docs.unity3d.com/2020.1/Documentation/Manual/AndroidAARPlugins.html#:~:text=Use%20Android%20Libraries%20to%20reuse,for%20an%20Android%20app%20module)).
- Develop and debug core functionality in isolation (with unit tests or the Android test app) to ensure reliability outside of Unity.
- Package the Unity plugin as an **AAR file** (contains Java code + manifest). This is the Unity-supported and recommended plugin format ([Unity - Manual: Introducing Android Library and Android Archive plug-ins](https://docs.unity3d.com/6000.0/Documentation/Manual/android-library-project-and-aar-plugins-introducing.html#:~:text=Android%20Archives%20are%20a%20compiled,the%20future%2C%20or%20want%20to)) ([Unity - Manual: Introducing Android Library and Android Archive plug-ins](https://docs.unity3d.com/6000.0/Documentation/Manual/android-library-project-and-aar-plugins-introducing.html#:~:text=An%20Android%20Archive%20%28AAR%29%20plug,of%20an%20AAR%2C%20refer%20to)). It simplifies distribution since the manifest and any resources are included in one file.
- **Include necessary manifest entries in the AAR’s manifest** (permissions, etc.) so Unity merges them automatically during build ([Managing the Android Manifest in Unity - DEV Community](https://dev.to/attiliohimeki/managing-the-android-manifest-in-unity-221o#:~:text=Finally%2C%20most%20Plug,to%20make%20them%20work%20together)). Avoid anything in the manifest that could conflict with Unity’s own settings (don’t override the application or uses-sdk).
- In Unity, add the AAR (and the core .jar if applicable) to `Assets/Plugins/Android`, and mark them for Android in the Inspector ([Unity - Manual:  AAR plug-ins and Android Libraries](https://docs.unity3d.com/2020.1/Documentation/Manual/AndroidAARPlugins.html#:~:text=To%20add%20an%20AAR%20plug,file%20as%20compatible%20with%20Unity)). Unity will then integrate them into the Android build with no additional configuration needed.
- Avoid complex Gradle tricks or custom build steps – they shouldn’t be necessary. The standard Gradle build outputs and Unity’s plugin import mechanism are sufficient. Keep Gradle configs basic (just declare module dependencies and let Gradle handle the rest).
- Test the end-to-end pipeline: after importing into Unity, do an Android build of a Unity project to ensure the APK includes the plugin and that the manifest entries appear in the final merged `AndroidManifest.xml`. (You can find the merged manifest in Unity’s build output if needed, or use Android Studio’s APK Analyzer ([Managing the Android Manifest in Unity - DEV Community](https://dev.to/attiliohimeki/managing-the-android-manifest-in-unity-221o#:~:text=You%20can%20inspect%20the%20final,navigating%20to%20the%20manifest%20folder)) to verify).
  
By following this structured approach, you get a clean separation of core logic from Unity-specific code, and a hassle-free integration process. The Unity plugin AAR encapsulates everything needed for Unity, thus **minimizing manual setup and risk of manifest conflicts**. This modular design will make it easier to maintain the code, update the core functionality independently, and ensure compatibility with Unity’s Android build process now and in the future.

**References:**

- Unity Manual – *AAR plug-ins and Android Libraries*: Explains using Android libraries (AAR) to share code across applications ([Unity - Manual:  AAR plug-ins and Android Libraries](https://docs.unity3d.com/2020.1/Documentation/Manual/AndroidAARPlugins.html#:~:text=Use%20Android%20Libraries%20to%20reuse,for%20an%20Android%20app%20module)) ([Unity - Manual:  AAR plug-ins and Android Libraries](https://docs.unity3d.com/2020.1/Documentation/Manual/AndroidAARPlugins.html#:~:text=To%20add%20an%20AAR%20plug,file%20as%20compatible%20with%20Unity)) and how Unity imports AAR plug-ins.  
- Unity Manual – *Introducing Android Library and AAR plug-ins*: Recommends using AAR format for distributing Unity plugins ([Unity - Manual: Introducing Android Library and Android Archive plug-ins](https://docs.unity3d.com/6000.0/Documentation/Manual/android-library-project-and-aar-plugins-introducing.html#:~:text=Android%20Archives%20are%20a%20compiled,the%20future%2C%20or%20want%20to)) ([Unity - Manual: Introducing Android Library and Android Archive plug-ins](https://docs.unity3d.com/6000.0/Documentation/Manual/android-library-project-and-aar-plugins-introducing.html#:~:text=An%20Android%20Archive%20%28AAR%29%20plug,of%20an%20AAR%2C%20refer%20to)).  
- *Managing the Android Manifest in Unity* (Attilio Himeki, *Dev.to*): Describes Unity’s manifest merging process, noting that plugin manifests get merged automatically if designed properly ([Managing the Android Manifest in Unity - DEV Community](https://dev.to/attiliohimeki/managing-the-android-manifest-in-unity-221o#:~:text=Finally%2C%20most%20Plug,to%20make%20them%20work%20together)) ([Managing the Android Manifest in Unity - DEV Community](https://dev.to/attiliohimeki/managing-the-android-manifest-in-unity-221o#:~:text=At%20build%20time%20Unity%20will,the%20Plugins%20and%20SDKs%20manifests)).  
- Vishnu Sivan – *Creating and importing a custom Android library in Unity3D*: Tutorial illustrating how to build an Android Library (AAR) and import it into Unity ([Create and import a custom android library in Unity3D | by Vishnu Sivan | Medium](https://codemaker2016.medium.com/create-and-import-a-custom-android-library-in-unity3d-ed7f848c6c54#:~:text=After%20compilation%2C%20you%20will%20find,name%3E%5Cbuild%5Coutputs%5Caar%60%20folder)) ([Create and import a custom android library in Unity3D | by Vishnu Sivan | Medium](https://codemaker2016.medium.com/create-and-import-a-custom-android-library-in-unity3d-ed7f848c6c54#:~:text=Open%20your%20Unity3D%20project%20and,debug.aar%60%29%20inside%20the%20folder)).